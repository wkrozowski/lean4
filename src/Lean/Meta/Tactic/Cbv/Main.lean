module

prelude
public import Lean.Meta.Tactic.Cbv.Types
public import Lean.Meta.Tactic.Delta
public import Lean.Meta.Tactic.Unfold
public import Lean.Meta.Tactic.Simp.Main
public import Lean.Meta.Tactic.Apply
public import Lean.Meta.Closure
import Lean.Meta.Tactic.Assumption
import Lean.Meta.Tactic.Contradiction
import Lean.Meta.Tactic.Generalize
import Lean.Meta.Tactic.Refl
import Lean.Meta.Basic
import Lean.Elab.PreDefinition.EqUnfold

public section

namespace Lean.Meta.Tactic.Cbv

/--
  Quotient reduction rules:
  Quot.lift (4 args) and Quot.ind (4 args) reduce if the 4th arg is Quot.mk
  -/
def isQuotRedex (info : QuotVal) (args : Array Expr) : MetaM Bool := do
  match info.kind with
  | .lift | .ind =>
    if args.size < 4 then return false
    let majorArg := args[3]!
    return majorArg.getAppFn.isConstOf ``Quot.mk
  | .ctor | .type => return false

partial def isValue (e : Expr) : MetaM Bool := do
  trace[Meta.Tactic] "checking if {e} is a value"
  -- Not sure if this should be treated as value or not
  if ((← inferType e).isProp) then
    return true

  -- Proof terms are values
  if (← isProof e) then
    return true

  -- 2. Handle Nat literals represented via OfNat.ofNat
  if Simp.isOfNatNatLit e then
    trace[Meta.Tactic] "It is nat literal"
    return true

  match e with
  | .lit _   => return true
  | .sort _  => return true
  | .lam ..  => return true -- Lambdas are values in CBV
  | .forallE .. => return true
  | .mdata _ e => isValue e

  -- 3. Handle Constants (No arguments)
  | .const .. => return false

  -- 4. Handle Applications
  | .app .. =>
    let fn := e.getAppFn
    let args := e.getAppArgs
    match fn with
    | .const name _ =>
      let info ← getConstInfo name
      match info with
      | .ctorInfo _ | .inductInfo _ | .axiomInfo _ =>
        -- Constructors, inductive types, and axioms applied to values are values
        args.allM isValue
       | .quotInfo quotVal =>
        if (← isQuotRedex quotVal args) then
          return false
        else
          args.allM isValue
      | .thmInfo _ => return true
      | .defnInfo _ | .opaqueInfo _ | .recInfo _ =>
        -- Definitions/Recursors are reducible; even if arguments are values, the call is not
        return false
    | _ => return false
  -- Explicitly not values
  | .letE .. | .proj .. => return false
  | .bvar .. => throwError "Unexpected bound variable encountered: {e}"
  | .fvar .. => throwError "Unexpected free variable encountered: {e}"
  | .mvar _ => throwError "Unassigned metavariable encountered: {e}"

where
  /-- Helper to determine if a standalone constant is a value based on its declaration type -/
  isConstantValue (name : Name) : MetaM Bool := do
    let info ← getConstInfo name
    return match info with
    | .ctorInfo _ | .axiomInfo _ | .thmInfo _ | .inductInfo _ | .quotInfo _ => true
    | .defnInfo _ | .opaqueInfo _ | .recInfo _ => false

/-
  TODO: Memoize this function and register the proofs separately

  Takes a function type, arguments of congruence theorem generated by `mkHCongrWithArity`, result type and heterogenous equality proof
  between substituted function application and the result.
-/
def genCombinationHEqWithArity (funType : Expr) (arity : Nat) : MetaM (Expr × Array CongrArgKind) := do
  let ⟨proof, kinds⟩ ← withLocalDeclD `f funType fun fVar => do
    let hCongrThm ← mkHCongrWithArity fVar arity
    forallTelescope hCongrThm.type fun args _ => do
      let congrProof := mkAppN hCongrThm.proof args
      let some (_, _, type, value) := (← inferType congrProof).heq? | throwError "Heterogenous equality expected"
      let level ← getLevel type
      let type := mkSort level

      withLocalDeclD `gType type fun resultType => do
      withLocalDeclD `g resultType fun gVar => do
          let remainingHEqType ← mkHEq value gVar
          withLocalDeclD `heq remainingHEqType fun remainingHEq => do
            let res ← mkHEqTrans congrProof remainingHEq
            let res ← mkLambdaFVars #[resultType, gVar, remainingHEq] res
            let res ← mkLambdaFVars args res
            let res ← mkLambdaFVars #[fVar] res
            return (res, hCongrThm.argKinds)
  let proof ← Lean.Meta.mkAuxTheorem (← inferType proof) proof (cache := true)
  return ⟨proof, kinds⟩

def getCombinationHEqWithArity (funType : Expr) (arity : Nat) : CbvM (Expr × Array CongrArgKind) := do
  let key : Key := { functionType := funType, arity := arity }
  let state ← get
  if let some proof := state.find? key then
    trace[Meta.Tactic.cbv] m!"{checkEmoji} Retrieving a combination HEq for {funType}"
    return ⟨proof.proof, proof.argKinds⟩
  else
    trace[Meta.Tactic.cbv] m!"{checkEmoji} Generating new combination HEq for {funType} with arity {arity}"
    let (proof, kinds) ← genCombinationHEqWithArity funType arity
    let type ← inferType proof
    modify fun s => s.insert key { type := type,
                                   proof := proof,
                                   argKinds := kinds }
    return ⟨proof, kinds⟩

def tryValue' (e : Expr) : CbvM Result := do
  trace[Meta.Tactic.cbv] m!"{checkEmoji} {e} is a value."
  pure <| {value := e, proof := ← mkHEqRefl e, isValue := true}

def handleLambda' (lambdaFn : Expr) (args : Array Expr) (callback : Expr → CbvM Result) : CbvM Result := do
  guard lambdaFn.isLambda
  let fnType ← inferType lambdaFn
  let evaluated ← args.mapM callback
  let toApply := args.zip evaluated

  -- We continue evaluation on the substituted function application
  let toContinue := mkAppN lambdaFn <| evaluated.map (·.value)
  let toContinue := toContinue.headBeta
  let continuedResult ← callback toContinue
  let continuedResultType ← inferType continuedResult.value

  let (congruenceProof, kinds) ← getCombinationHEqWithArity fnType args.size
  let mut congruenceProof := Expr.app congruenceProof lambdaFn

  -- We apply all the arguments to the congruence lemma
  for ((arg, evalResult), kind) in toApply.zip kinds do
    congruenceProof := mkAppN congruenceProof #[arg, evalResult.value]
    let mut proof := evalResult.proof
    if kind == .eq then
      proof ← mkEqOfHEq proof
    congruenceProof := .app congruenceProof proof

  congruenceProof := mkAppN congruenceProof #[continuedResultType, continuedResult.value, continuedResult.proof]
  return { value := continuedResult.value, proof := congruenceProof, isValue := false }

def handleDef' (name : Name) (levels : List Level) (args : Array Expr) (callback : Expr → CbvM Result) : CbvM Result := do
  trace[Meta.Tactic.cbv] "Handling definition application: {name} with levels {levels} and arguments {args}"
  let some unfoldEqName ← getConstUnfoldEqnFor? name | throwError
                "Could not obtain unfold equation for: {name}"
  let unfoldEq := mkConst unfoldEqName levels
  let some (_, _, rhs) := (← inferType unfoldEq).eq? | throwError "fatal error : equality expected at {←inferType unfoldEq}"

  -- We evaluate the new term
  let unfoldedApplication := mkAppN rhs args
  let evaluationResult ← callback unfoldedApplication

  let fType ← inferType rhs
  let congrArgFun ← withLocalDecl (← mkFreshUserName `x) BinderInfo.default fType fun var => do
    let theoremLhs := mkAppN var args
    let theoremBody ← mkHEq theoremLhs evaluationResult.value
    mkLambdaFVars #[var] theoremBody

  let congrArg ← mkCongrArg congrArgFun unfoldEq
  let finalProof ← mkAppOptM ``Eq.mpr #[none, none, congrArg, evaluationResult.proof]

  return {value := evaluationResult.value, proof := finalProof, isValue := true }

/-
  TODO : Take a parameter for a result type to generate a proper chaining lemma.
-/
def genCongrEqnForMatcher (name : Name) (levels : List Level) (matcherInfo : Match.MatcherInfo) : CbvM Result := do
  let some hCongrThm ← mkHCongrWithArityForConst? name levels matcherInfo.arity | throwError "Could not genereate congruence theorem for matcher {name}"
  let congrEqns ← Match.genMatchCongrEqns name
  let congrEqns := congrEqns.map (mkConst · levels)
  let congrEqns ← congrEqns.mapM fun matchCongrEqn => do
    forallTelescope hCongrThm.type fun congrArgs congrBody => do
      let some (_, _, _, rhs) := congrBody.heq? | throwError "Heterogenous equality expected"
      let appliedCongrThm := mkAppN hCongrThm.proof congrArgs
      let matchCongrEqn := mkAppN matchCongrEqn (rhs.getAppArgs)
      forallTelescope (← inferType matchCongrEqn) fun matchArgs matchBody => do
        let some (_, _, resultValue, value) := matchBody.heq? | throwError "Heterogenous equality expected"
        let appliedMatchCongrEqn := mkAppN matchCongrEqn matchArgs
        let composedProof ← mkHEqTrans appliedCongrThm appliedMatchCongrEqn
        let level ← getLevel resultValue
        let resultType := mkSort level
        withLocalDeclD `g resultType fun gVar => do
          let heqType ← mkHEq value gVar
          withLocalDeclD `heq heqType fun heqVar => do
            let finalProof ← mkHEqTrans composedProof heqVar
            mkLambdaFVars (congrArgs ++ matchArgs ++ #[gVar, heqVar]) finalProof
  throwError "congrEqns: {congrEqns}"

def handleMatcher' (name : Name) (levels : List Level) (args : Array Expr) (callback : Expr → CbvM Result) (matcherInfo : Match.MatcherInfo) : CbvM Result := do
  trace[Meta.Tactic.cbv] "Handling matcher application: {name} with levels {levels} and arguments {args}"
  -- unless matcherInfo.arity == args.size do
  --   throwError "Matcher arity mismatch: expected {matcherInfo.arity}, got {args.size} - cannot handle that yet"
  let some hCongrThm ← mkHCongrWithArityForConst? name levels matcherInfo.arity | throwError "Could not genereate congruence theorem for matcher {name}"
  let mut hCongrThmProof := hCongrThm.proof
  let mut newArgs : Array Expr := #[]
  let params := args.extract 0 matcherInfo.getFirstAltPos
  let paramsKinds := hCongrThm.argKinds.extract 0 matcherInfo.getFirstAltPos
  let evaluatedParams ← params.mapM callback
  let toApply := params.zip evaluatedParams
  newArgs := newArgs ++ evaluatedParams.map (·.value)

  for ((param, evalResult), kind) in toApply.zip paramsKinds do
    hCongrThmProof := mkAppN hCongrThmProof #[param, evalResult.value]
    let mut proof := evalResult.proof
    if kind == .eq then
      proof ← mkEqOfHEq proof
    hCongrThmProof := .app hCongrThmProof proof

  let ⟨firstAltPos, lastAltPos⟩ := matcherInfo.getAltRange
  let alts := args.extract firstAltPos lastAltPos
  newArgs := newArgs ++ alts
  let altKinds := hCongrThm.argKinds.extract firstAltPos lastAltPos

  for (alt, kind) in alts.zip altKinds do
    hCongrThmProof := mkAppN hCongrThmProof #[alt, alt]
    match kind with
    | .eq => hCongrThmProof := mkApp hCongrThmProof (← mkEqRefl alt)
    | .heq => hCongrThmProof := mkApp hCongrThmProof (← mkHEqRefl alt)
    | _ => throwError "Unexpected congruence kind in matcher alternatives"

  let congrEqns ← Match.genMatchCongrEqns name
  let congrEqns := congrEqns.map (mkConst · levels)
  let congrEqns := congrEqns.map (mkAppN · newArgs)

  let mut candidate : Option Expr := .none

  for congrEqn in congrEqns do
    try
      trace[Meta.Tactic.cbv] "Trying congrEqn: {congrEqn}"
      let (fvars, _) ← forallMetaTelescope (← inferType congrEqn)
      let fvars := fvars.map (·.mvarId!)
      for fvar in fvars do
        let fvarType ← fvar.getType
        if Simp.isEqnThmHypothesis fvarType then
          let (_, fvar) ← fvar.intros
          fvar.contradiction
          guard (←fvar.isAssigned)
        if (fvarType.isEq) then
          fvar.refl
        if (fvarType.isHEq) then
          fvar.hrefl
      guard (← fvars.allM (·.isAssigned))
      let fvars := fvars.map Expr.mvar
      let fvars ← fvars.mapM instantiateMVars
      candidate := (mkAppN congrEqn fvars)
    catch _ =>
      trace[Meta.Tactic.cbv] "Failed to apply congrEqn: {congrEqn}"
      continue

  let some resolvedCandidate := candidate | throwError "Could not find a matching congruence equation for matcher {name}"
  let some (_, _, _, value) := (← inferType resolvedCandidate).heq? | throwError "Heterogenous equality expected"

  if matcherInfo.arity < args.size then
    let remainingArgs := args.extract matcherInfo.arity args.size
    let toEvaluate := mkAppN value remainingArgs
    let continuedResult ← callback toEvaluate
    let resolvedCandidate ← mkEqOfHEq resolvedCandidate
    let some (type, _, _) := (← inferType resolvedCandidate).eq? | throwError "Equality expected"
    let congrArgFun ← withLocalDecl (← mkFreshUserName `x) BinderInfo.default type fun var => do
      let theoremLhs := mkAppN var remainingArgs
      let theoremBody ← mkHEq theoremLhs continuedResult.value
      mkLambdaFVars #[var] theoremBody

    let congrArg ← mkCongrArg congrArgFun resolvedCandidate
    let finalProof ← mkAppOptM ``Eq.mpr #[none, none, congrArg, continuedResult.proof]
    return { value := continuedResult.value, proof := finalProof, isValue := true }

  else
    let continuedEvaluationResult ← callback value
    let composedProof ← mkHEqTrans hCongrThmProof resolvedCandidate
    let composedProof ← mkHEqTrans composedProof continuedEvaluationResult.proof

    return { value := continuedEvaluationResult.value, proof := composedProof, isValue := true }

def handleIrreducibleConst' (name : Name) (levels : List Level) (args : Array Expr) (callback : Expr → CbvM Result) : CbvM Result := do
  trace[Meta.Tactic.cbv] "Handling application to an irreducible const: {name} with levels {levels} and arguments {args}"
  let some congrThm ← mkHCongrWithArityForConst? name levels args.size | throwError "Could not genereate congruence theorem for constructor {name}"

  -- We evaluate all the arguments
  let evaluated ← args.mapM callback
  let toApply := args.zip evaluated

  let mut congruenceProof := congrThm.proof
  -- We apply all the arguments to the congruence lemma
  for ((arg, evalResult), kind) in toApply.zip congrThm.argKinds do
    congruenceProof := mkAppN congruenceProof #[arg, evalResult.value]
    let mut proof := evalResult.proof
    if kind == .eq then
      proof ← mkEqOfHEq proof
    congruenceProof := .app congruenceProof proof

  let some (_, _, _, value) := (← inferType congruenceProof).heq? | throwError "Heterogenous equality expected"
  return { value := value, proof := congruenceProof, isValue := true }

def handleRec (name : Name) (levels : List Level) (args : Array Expr) (callback : Expr → CbvM Result) : CbvM Result := do
  trace[Meta.Tactic.cbv] "Handling recursor application: {name} with levels {levels} and arguments {args}"
  let evaluated ← args.mapM callback
  let newFn := mkConst name levels
  let newApplication := mkAppN newFn (evaluated.map (·.value))
  let some newApplication ← reduceRecMatcher? newApplication | throwError "Could not reduce recursor application {newApplication}"
  let evaluatedResult ← callback newApplication
  let recursorType ← inferType (mkConst name levels)

  let ⟨congrThm, argKinds⟩ ← getCombinationHEqWithArity recursorType args.size

  let toApply := args.zip evaluated
  let mut congruenceProof := mkAppN congrThm #[newFn]

  -- We apply all the arguments to the congruence lemma
  for ((arg, evalResult), kind) in toApply.zip argKinds do
    congruenceProof := mkAppN congruenceProof #[arg, evalResult.value]
    let mut proof := evalResult.proof
    if kind == .eq then
      proof ← mkEqOfHEq proof
    congruenceProof := .app congruenceProof proof
  congruenceProof := mkAppN congruenceProof #[recursorType, evaluatedResult.value, evaluatedResult.proof]

  return { value := evaluatedResult.value, proof := congruenceProof, isValue := true }

def handleConst' (name : Name) (levels : List Level) (args : Array Expr) (callback : Expr → CbvM Result) : CbvM Result := do
  trace[Meta.Tactic.cbv] "Handling constant application: {name} with levels {levels} and arguments {args}"
  let info ← getConstInfo name
  match info with
  | .defnInfo _ =>
    let matcherInfo ← getMatcherInfo? name
    -- Probably here I should also apply function congruence lemmas
    if matcherInfo.isSome then
      handleMatcher' name levels args callback matcherInfo.get!
    else
      handleDef' name levels args callback
  | .ctorInfo _ => handleIrreducibleConst' name levels args callback
  | .inductInfo _ => handleIrreducibleConst' name levels args callback
  | .axiomInfo _ => handleIrreducibleConst' name levels args callback
  | .opaqueInfo _ => handleIrreducibleConst' name levels args callback
  | .thmInfo _ => throwError "Should have been caught by isValue earlier"
  | .recInfo _ => handleRec name levels args callback
  | .quotInfo _ =>
    let res ← handleIrreducibleConst' name levels args callback
    if let some toContinue ← reduceRecMatcher? res.value then
      let continuedResult ← callback toContinue
      let proof ← mkHEqTrans res.proof continuedResult.proof
      return {value := continuedResult.value, proof := proof, isValue := true}
    else
      return res

def handleAppDefault (fn : Expr) (args : Array Expr) (callback : Expr → CbvM Result) : CbvM Result := do
  trace[Meta.Tactic.cbv] "Handling the general case of an application: function {fn}, type: {← inferType fn}, arguments: {args}"
  guard !(← isValue fn)

  -- We evaluate the left hand side to a value
  let funArgResult ← callback fn
  let funArgValue := funArgResult.value

  -- We create a new expression to evaluate
  let continuedExpr := mkAppN funArgValue args
  let continuedResult ← callback continuedExpr

  let fnType ← inferType fn
  let congrArgFun ← withLocalDecl (← mkFreshUserName `x) BinderInfo.default fnType fun var => do
    let theoremLhs := mkAppN var args
    let theoremBody ← mkHEq theoremLhs continuedResult.value
    mkLambdaFVars #[var] theoremBody

  let congrArg ← mkCongrArg congrArgFun (← mkEqOfHEq funArgResult.proof)
  let finalProof ← mkAppOptM ``Eq.mpr #[none, none, congrArg, continuedResult.proof]

  return { value := continuedResult.value, proof := finalProof, isValue := true }

def handleApp' (fn : Expr) (args : Array Expr) (callback : Expr → CbvM Result) : CbvM Result := do
  trace[Meta.Tactic.cbv] "Evaluating an application: function {fn}, type: {← inferType fn}, arguments: {args}"
  match fn with
  | .lam .. => handleLambda' fn args callback
  | .const name levels => handleConst' name levels args callback
  | _ => handleAppDefault fn args callback

def handleProj' (typeName : Name) (idx : Nat) (val : Expr) (callback : Expr → CbvM Result) : CbvM Result := do
  trace[Meta.Tactic.cbv] "Handling projection expression of the type {typeName}, index {idx} and inner expression {val}"
  let innerResult ← callback val
  let innerValue := innerResult.value

  -- We solve the projection
  let newExpr := Expr.proj typeName idx innerValue
  let some reduced ← reduceProj? newExpr | throwError "Could not reduce projection {newExpr}"

  -- We continue evaluation
  let continuedResult ← callback reduced

  let fType ← inferType val
  let congrArgFun ← withLocalDecl (← mkFreshUserName `x) BinderInfo.default fType fun var => do
    let theoremLhs := Expr.proj typeName idx var
    let theoremBody ← mkHEq theoremLhs continuedResult.value
    mkLambdaFVars #[var] theoremBody

  let congrArg ← mkCongrArg congrArgFun (← mkEqOfHEq innerResult.proof)

  let finalProof ← mkAppOptM ``Eq.mpr #[none, none, congrArg, continuedResult.proof]
  return { value := continuedResult.value, proof := finalProof, isValue := true }

partial def cbvCore' (e : Expr) : CbvM Result := do
  trace[Meta.Tactic.cbv] "cbvCore' called on {e}"
  if (← isValue e) then
    tryValue' e
  else
    match e with
    | .app .. => handleApp' e.getAppFn e.getAppArgs cbvCore'
    | .const .. => return {value := e , proof := ← mkHEqRefl e, isValue := true}
    | .proj typeName idx val => handleProj' typeName idx val cbvCore'
    | .letE .. =>
      let reduced ← zetaReduce e
      cbvCore' reduced
    | _ => throwError "cbvCore': not implemented for {e}"

def cbv (e : Expr) : MetaM Result := do
  let ⟨⟨value, proof, isVal⟩, compositionThms ⟩ ← (cbvCore' e).run {}

  trace[Meta.Tactic.cbv] "Generated {compositionThms.toList.length} composition theorems during CBV evaluation."
  return { value := value, proof := ← mkEqOfHEq proof, isValue := isVal }


end Lean.Meta.Tactic.Cbv
