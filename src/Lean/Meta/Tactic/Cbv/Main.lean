module

prelude
public import Lean.Meta.Tactic.Cbv.Types
public import Lean.Meta.Tactic.Cbv.CbvProc
public import Lean.Meta.Tactic.Delta
public import Lean.Meta.Tactic.Unfold
public import Lean.Meta.Tactic.Simp.Main
public import Lean.Meta.Tactic.Apply
public import Lean.Meta.Closure
public import Init.Data.Nat.Basic
import Lean.Meta.Tactic.Assumption
import Lean.Meta.Tactic.Contradiction
import Lean.Meta.Tactic.Generalize
import Lean.Meta.Tactic.Refl
import Lean.Meta.Basic
import Lean.Elab.PreDefinition.EqUnfold

public section

namespace Lean.Meta.Tactic.Cbv

def mkLeftCongruence (fnType : Expr) (numArgs : Nat) : MetaM Expr := do
  let proof ← withLocalDeclD `f fnType fun f => do
    withLocalDeclD `g fnType fun g => do
      let eqType ← mkEq f g
      withLocalDeclD `eq eqType fun heq => do
        withLocalDeclD `x fnType fun x => do
            forallBoundedTelescope fnType numArgs fun args _ => do
            let applied := mkAppN x args
            let appliedType ← inferType applied
            let level ← getLevel appliedType
            let sort := mkSort level
            withLocalDeclD `type sort fun resultType =>
              withLocalDeclD `value resultType fun value => do
                let res ← mkHEq applied value
                let res ← mkLambdaFVars #[x] res
                let res ← mkCongrArg res heq
                let res ← mkAppOptM ``Eq.mpr #[none, none, res]
                let res ← mkLambdaFVars #[resultType, value] res
                let res ← mkLambdaFVars args res
                mkLambdaFVars #[f,g, heq] res
  mkAuxTheorem (← inferType proof) proof (cache := true)

def getLeftCongruence (funType : Expr) (arity : Nat) : CbvM Expr := do
  let key : Key := { functionType := funType, arity := arity }
  let state ← get
  if let some proof := state.leftCongruenceThms.get? key then
    trace[Meta.Tactic.cbv.congr] m!"{checkEmoji} retrieved cached left congruence lemma for {funType}"
    return proof
  else
    trace[Meta.Tactic.cbv.congr] m!"generating new left congruence lemma for {funType} with arity {arity}"
    let proof ← mkLeftCongruence funType arity
    modify fun s => {s with leftCongruenceThms := s.leftCongruenceThms.insert key proof}
    return proof

/--
  Quotient reduction rules:
  Quot.lift (4 args) and Quot.ind (4 args) reduce if the 4th arg is Quot.mk
  -/
def isQuotRedex (info : QuotVal) (args : Array Expr) : MetaM Bool := do
  match info.kind with
  | .lift | .ind =>
    if args.size < 4 then return false
    let majorArg := args[3]!
    return majorArg.getAppFn.isConstOf ``Quot.mk
  | .ctor | .type => return false

partial def isValue (e : Expr) : CbvM Bool := do
  trace[Debug.Meta.Tactic.cbv] "checking if {e} is a value"
  if (← get)|>.fullyEvaluated.contains e then
    trace[Debug.Meta.Tactic.cbv] "{e} is a value that we have seen before"
    return true

  -- Proof terms are values
  if (← isProof e) then
    return true

  -- 2. Handle Nat literals represented via OfNat.ofNat
  if Simp.isOfNatNatLit e then
    return true

  match e with
  | .lit _   => return true
  | .sort _  => return true
  | .lam ..  => return true -- Lambdas are values in CBV
  | .forallE .. => return true
  | .mdata _ e => isValue e

  -- 3. Handle Constants (No arguments)
  | .const name _ => isConstantValue name

  -- 4. Handle Applications
  | .app .. =>
    let fn := e.getAppFn
    let args := e.getAppArgs
    match fn with
    | .const name _ =>
      let info ← getConstInfo name
      match info with
      | .ctorInfo _ | .inductInfo _ | .axiomInfo _ =>
        -- Constructors, inductive types, and axioms applied to values are values
        args.allM isValue
       | .quotInfo quotVal =>
        if (← isQuotRedex quotVal args) then
          return false
        else
          args.allM isValue
      | .thmInfo _ => return true
      | .defnInfo _ | .opaqueInfo _ | .recInfo _ =>
        -- Definitions/Recursors are reducible; even if arguments are values, the call is not
        return false
    | _ => return false
  -- Explicitly not values
  | .letE .. | .proj .. => return false
  | .bvar .. => throwError "Unexpected bound variable encountered: {e}"
  | .fvar .. => throwError "Unexpected free variable encountered: {e}"
  | .mvar _ => throwError "Unassigned metavariable encountered: {e}"

where
  /-- Helper to determine if a standalone constant is a value based on its declaration type -/
  isConstantValue (name : Name) : MetaM Bool := do
    let info ← getConstInfo name
    return match info with
    | .ctorInfo _ | .axiomInfo _ | .thmInfo _ | .inductInfo _ | .quotInfo _ | .opaqueInfo _ | .recInfo _  => true
    | .defnInfo _ => false

/-
  Takes a function type, arguments of congruence theorem generated by `mkHCongrWithArity`, result type and heterogenous equality proof
  between substituted function application and the result.
-/
def genCombinationHEqWithArity (funType : Expr) (arity : Nat) : MetaM (Expr × Array CongrArgKind) := do
  let ⟨proof, kinds⟩ ← withLocalDeclD `f funType fun fVar => do
    trace[Meta.Tactic.cbv] "Generating combination HEq, funType: {funType}, arity: {arity}, fVar: {fVar}"
    let hCongrThm ← mkHCongrWithArity fVar arity
    forallTelescope hCongrThm.type fun args _ => do
      let congrProof := mkAppN hCongrThm.proof args
      let some (_, _, type, value) := (← inferType congrProof).heq? | throwError "Heterogenous equality expected"
      let level ← (getLevel type)
      let type := mkSort level

      withLocalDeclD `gType type fun resultType => do
      withLocalDeclD `g resultType fun gVar => do
          let remainingHEqType ← mkHEq value gVar
          withLocalDeclD `heq remainingHEqType fun remainingHEq => do
            let res ← mkHEqTrans congrProof remainingHEq
            let res ← mkLambdaFVars #[resultType, gVar, remainingHEq] res
            let res ← mkLambdaFVars args res
            let res ← mkLambdaFVars #[fVar] res
            return (res, hCongrThm.argKinds)
  let proof ← Lean.Meta.mkAuxTheorem (← inferType proof) proof (cache := true)
  return ⟨proof, kinds⟩

def getCombinationHEqWithArity (funType : Expr) (arity : Nat) : CbvM (Expr × Array CongrArgKind) := do
  let key : Key := { functionType := funType, arity := arity }
  let state ← get
  if let some proof := state.compositionThms.get? key then
    trace[Meta.Tactic.cbv.congr] m!"{checkEmoji} retrieved cached combination HEq for {funType}"
    return ⟨proof.proof, proof.argKinds⟩
  else
    trace[Meta.Tactic.cbv.congr] m!"generating new combination HEq for {funType} with arity {arity}"
    let (proof, kinds) ← genCombinationHEqWithArity funType arity
    let type ← inferType proof
    modify fun s => {s with compositionThms := s.compositionThms.insert key { type := type, proof := proof, argKinds := kinds }}
    return ⟨proof, kinds⟩

def tryValue (e : Expr) : CbvM Result := do
  trace[Meta.Tactic.cbv.value] m!"{checkEmoji} {e} is a value"
  pure <| {value := e, proof := ← mkHEqRefl e, isValue := true}

def normNat (e : Expr) (callback : Expr → CbvM Result) : CbvM (Option Result) := do
  if (e.isConstOf `Nat.zero) then
    return some { value := mkNatLit 0
                  proof := ← mkHEqRefl e
                  isValue := true }
  if (e.isAppOfArity `Nat.succ 1) then
    let_expr Nat.succ f := e | return none
    let evalRes ← callback f
    let some n ← getNatValue? evalRes.value | return none
    let newValue := mkNatLit <| n + 1
    let (combinationHEq, _) ← getCombinationHEqWithArity (← mkArrow (mkConst `Nat) (mkConst `Nat)) 1
    let combinationHEq := Expr.app combinationHEq (mkConst `Nat.succ)
    let combinationHEq := mkAppN combinationHEq #[f, mkNatLit n, (← mkEqOfHEq evalRes.proof), mkConst `Nat, newValue, ← mkHEqRefl newValue]
    return some { value := newValue, proof := combinationHEq, isValue := true }
  if (e.isAppOfArity ``HAdd.hAdd 6) then
    let_expr HAdd.hAdd Nat Nat Nat _ arg1 arg2 := e | return none
    let eval1 ← callback arg1
    let eval2 ← callback arg2
    let some value1 ← getNatValue? eval1.value | return none
    let some value2 ← getNatValue? eval2.value | return none
    let newValue := mkNatLit (value1 + value2)
    let proof ← mkAppOptM ``Nat.natAdditionCast #[arg1, arg2, eval1.value, eval2.value, eval1.proof, eval2.proof]
    return some { value := newValue
                  proof := proof
                  isValue := true }
  else
    return none

partial def congrThmTelescopeWithMask (c : CongrTheorem) (mask : Array Bool) (k : Array Expr → Array CbvCongrArgKind → Expr → MetaM α) : MetaM α := do
  guard (c.argKinds.size == mask.size)
  go #[] c.type 0 c.proof #[]
where
  go (soFar : Array Expr) (e : Expr) (n : Nat) (acc : Expr) (kinds : Array CbvCongrArgKind) := do
    if n == mask.size then
      k soFar kinds acc
    else
      forallBoundedTelescope e (.some 3) fun args body => do
        let argTy0 ← inferType args[0]!
        let argTy1 ← inferType args[1]!
        let areDefEq ← isDefEq argTy0 argTy1
        if (mask[n]! && areDefEq) then
          let rflProof ← if c.argKinds[n]! == .eq then (mkEqRefl args[0]!) else (mkHEqRefl args[0]!)
          let newAcc := mkApp3 acc args[0]! args[0]! rflProof
          let newBody ← inferType newAcc
          go (soFar.push args[0]!) newBody (n + 1) newAcc (kinds.push .value)
        else
          let kind : CbvCongrArgKind := if mask[n]! then .refl else .eval
          let newKinds := kinds.push kind
          if c.argKinds[n]! == .eq then
            let newHypType ← mkHEq args[0]! args[1]!

            withLocalDeclD `h newHypType fun newHyp => do
              let eqProof ← mkEqOfHEq newHyp
              let newBody := (mkApp3 acc args[0]! args[1]! eqProof)
              go (soFar ++ #[args[0]!, args[1]!, newHyp]) (← inferType newBody) (n + 1) newBody newKinds
          else
            go (soFar ++ args) body (n + 1) (mkAppN acc args) newKinds


def mkHCongrWithMask (fn : Expr) (mask : Array Bool) : MetaM (Expr × Array CbvCongrArgKind) := do
  let hCongrThm ← mkHCongrWithArity fn mask.size
  let (res, kinds) ← congrThmTelescopeWithMask hCongrThm mask fun args kinds body => do
    pure (← mkLambdaFVars args body, kinds)
  pure (←mkAuxTheorem (← inferType res) res (cache := true), kinds)

def handleLambdaApp (lambdaFn : Expr) (args : Array Expr) (callback : Expr → CbvM Result) : CbvM Result := do
  guard lambdaFn.isLambda
  let fnType ← inferType lambdaFn
  let lambdaArity := lambdaFn.getNumHeadLambdas
  let lambdaArgs := args.extract (stop := lambdaArity)
  let mask ← lambdaArgs.mapM isValue

  if lambdaArity < args.size then
    trace[Meta.Tactic.cbv.app] "handling over-applied lambda with {args.size} arguments (arity: {lambdaArity})"
  else
    trace[Meta.Tactic.cbv.app] "handling lambda application with {args.size} arguments"

  let evaluated ← lambdaArgs.mapM callback
  let toApply := lambdaArgs.zip evaluated

  -- We continue evaluation on the substituted function application
  let toContinue := mkAppN lambdaFn <| evaluated.map (·.value)
  let toContinue := toContinue.headBeta
  let continuedResult ← callback toContinue
  let continuedResultType ← inferType continuedResult.value

  trace[Debug.Meta.Tactic.cbv] "Arguments are: {args}, fnType: {fnType}, lambdaFn: {lambdaFn}"
  try
    let myCongThm ← mkHCongrWithMask lambdaFn mask
    trace[Debug.Meta.Tactic.cbv] "myCongThm: {myCongThm}, mask: {mask}"
  catch e =>
     trace[Debug.Meta.Tactic.cbv] "Failed with {e.toMessageData}, mask: {mask}, args: {args}"
  let (congruenceProof, kinds) ← getCombinationHEqWithArity fnType lambdaArgs.size
  let mut congruenceProof := Expr.app congruenceProof lambdaFn

  -- We apply all the arguments to the congruence lemma
  for ((arg, evalResult), kind) in toApply.zip kinds do
    congruenceProof := mkAppN congruenceProof #[arg, evalResult.value]
    let mut proof := evalResult.proof
    if kind == .eq then
      proof ← mkEqOfHEq proof
    congruenceProof := .app congruenceProof proof

  congruenceProof := mkAppN congruenceProof #[continuedResultType, continuedResult.value, continuedResult.proof]
  if (lambdaArity < args.size) then
    congruenceProof ← mkEqOfHEq congruenceProof
    let resultType ← inferType continuedResult.value
    let remainingArgs := args.extract (start := lambdaArity)
    let leftCongruenceTheorem ← getLeftCongruence resultType remainingArgs.size
    let some (_, lhs, rhs) := (← inferType congruenceProof).eq? | throwError "equality expected"
    let leftCongruenceTheorem := mkAppN leftCongruenceTheorem #[lhs, rhs, congruenceProof]
    let leftCongruenceTheorem := mkAppN leftCongruenceTheorem remainingArgs
    let toApply := mkAppN continuedResult.value remainingArgs
    let evalResult ← callback toApply
    let leftCongruenceTheorem := mkAppN leftCongruenceTheorem #[← (inferType evalResult.value), evalResult.value, evalResult.proof]
    return { value := evalResult.value, proof := leftCongruenceTheorem, isValue := true}
  else
    return { value := continuedResult.value, proof := congruenceProof, isValue := false }

def handleDef (name : Name) (levels : List Level) (args : Array Expr) (callback : Expr → CbvM Result) : CbvM Result := do
  trace[Meta.Tactic.cbv.unfold] "unfolding definition {name} with {args.size} arguments"

  let some unfoldEqName ← getConstUnfoldEqnFor? name | throwError
                "Could not obtain unfold equation for: {name}"
  let unfoldEq := mkConst unfoldEqName levels
  let some (_, _, rhs) := (← inferType unfoldEq).eq? | throwError "fatal error : equality expected at {←inferType unfoldEq}"

  -- We evaluate the new term
  let unfoldedApplication := mkAppN rhs args
  let evaluationResult ← callback unfoldedApplication

  let fType ← inferType rhs

  -- This cannot be replaced with a left congruence due to overapplication issues
  let congrArgFun ← withLocalDecl (← mkFreshUserName `x) BinderInfo.default fType fun var => do
    let theoremLhs := mkAppN var args
    let theoremBody ← mkHEq theoremLhs evaluationResult.value
    mkLambdaFVars #[var] theoremBody

  let congrArg ← mkCongrArg congrArgFun unfoldEq
  let finalProof ← mkAppOptM ``Eq.mpr #[none, none, congrArg, evaluationResult.proof]

  return {value := evaluationResult.value, proof := finalProof, isValue := true }

def genCongrEqnForMatcher (name : Name) (levels : List Level) (matcherInfo : Match.MatcherInfo) : MetaM (Array Expr × Array CongrArgKind) := do
  let some hCongrThm ← mkHCongrWithArityForConst? name levels matcherInfo.arity | throwError "Could not genereate congruence theorem for matcher {name}"
  let congrEqns ← Match.genMatchCongrEqns name
  let congrEqns := congrEqns.map (mkConst · levels)
  let res ← congrEqns.mapM fun matchCongrEqn => do
    forallTelescope hCongrThm.type fun congrArgs congrBody => do
      let some (_, _, _, rhs) := congrBody.heq? | throwError "Heterogenous equality expected"
      let appliedCongrThm := mkAppN hCongrThm.proof congrArgs
      let matchCongrEqn := mkAppN matchCongrEqn (rhs.getAppArgs)
      forallTelescope (← inferType matchCongrEqn) fun matchArgs matchBody => do
        let some (_, _, resultValue, value) := matchBody.heq? | throwError "Heterogenous equality expected"
        let appliedMatchCongrEqn := mkAppN matchCongrEqn matchArgs
        let composedProof ← mkHEqTrans appliedCongrThm appliedMatchCongrEqn
        let level ← getLevel resultValue
        let resultType := mkSort level
        withLocalDeclD `gType resultType fun gType => do
          withLocalDeclD `g gType fun gVar => do
            let heqType ← mkHEq value gVar
            withLocalDeclD `heq heqType fun heqVar => do
              let finalProof ← mkHEqTrans composedProof heqVar
              let finalProof ← mkLambdaFVars (congrArgs ++ matchArgs ++ #[gType, gVar, heqVar]) finalProof
              mkAuxTheorem (← inferType finalProof) finalProof (cache := true)
  return (res, hCongrThm.argKinds)

def handleIrreducibleConst (name : Name) (levels : List Level) (args : Array Expr) (callback : Expr → CbvM Result) : CbvM Result := do
  trace[Meta.Tactic.cbv.irreducible] "handling irreducible constant {name} with {args.size} arguments"
  let some congrThm ← mkHCongrWithArityForConst? name levels args.size | throwError "Could not genereate congruence theorem for constructor {name}"

  -- We evaluate all the arguments
  let evaluated ← args.mapM callback
  let toApply := args.zip evaluated

  let mut congruenceProof := congrThm.proof
  -- We apply all the arguments to the congruence lemma
  for ((arg, evalResult), kind) in toApply.zip congrThm.argKinds do
    congruenceProof := mkAppN congruenceProof #[arg, evalResult.value]
    let mut proof := evalResult.proof
    if kind == .eq then
      proof ← mkEqOfHEq proof
    congruenceProof := .app congruenceProof proof

  let some (_, _, _, value) := (← inferType congruenceProof).heq? | throwError "Heterogenous equality expected"
  return { value := value, proof := congruenceProof, isValue := true }

def handleMatcher (name : Name) (levels : List Level) (args : Array Expr) (callback : Expr → CbvM Result) (matcherInfo : Match.MatcherInfo) : CbvM Result := do
  withTraceNode `Meta.Tactic.cbv (fun
    | .ok result => return m!"matcher {name} with {args} => {result.value}"
    | .error err => return m!"evaluating matcher {name} failed => {err.toMessageData}") do
    trace[Meta.Tactic.cbv.matcher] "handling matcher {name} with {args.size} arguments (arity: {matcherInfo.arity})"
    -- In the underapplied case, we don't perform any unfolding.
    if args.size < matcherInfo.arity then
      trace[Meta.Tactic.cbv] "The matcher is under-applied"
      handleIrreducibleConst name levels args callback
    else
    -- Otherwise we handle all the arguments passed to a matcher and unfold it
    let (eqns, kinds) ← genCongrEqnForMatcher name levels matcherInfo
    let matcherArgs := args.extract (stop := matcherInfo.arity)
    -- let valueInfo ← matcherArgs.mapM isValue
    -- let _ ← genCongrEqnForMatcherWithMask name levels matcherInfo valueInfo
    let evaluatedArgs ← matcherArgs.mapM callback
    let toApply := matcherArgs.zip evaluatedArgs
    let eqns : Array Expr ← eqns.mapM fun eqn => do
      let mut eqn : Expr := eqn
      for ((arg, evalResult), kind) in toApply.zip kinds do
        eqn := mkAppN eqn #[arg, evalResult.value]
        let mut proof := evalResult.proof
        if (kind == .eq) then
          proof ← mkEqOfHEq proof
        eqn := Expr.app eqn proof
      return eqn
    let numPremises ← eqns.mapM (fun e => do return (← inferType e).getNumHeadForalls)

    let mut result : Option Expr := .none
    for (eqn, numPremises) in eqns.zip numPremises do
      guard (numPremises >= 3)
      try
        let (fvars, _) ← forallMetaBoundedTelescope (← inferType eqn) (numPremises - 3)
        let fvars := fvars.map (·.mvarId!)
        for fvar in fvars do
          let fvarType ← fvar.getType
          if Simp.isEqnThmHypothesis fvarType then
            let (_, fvar) ← fvar.intros
            fvar.contradiction
            guard (← fvar.isAssigned)
          if (fvarType.isEq) then
            fvar.refl
          if (fvarType.isHEq) then
            fvar.hrefl
        guard (← fvars.allM (·.isAssigned))
        let fvars := fvars.map Expr.mvar
        let fvars ← fvars.mapM instantiateMVars
        result := (mkAppN eqn fvars)
      catch _ =>
        trace[Meta.Tactic.cbv.matcher] "{bombEmoji} Failed to apply equation: {eqn}"
        continue

    let some resolvedCandidate := result | throwError "Could not find a matching congruence equation for matcher {name}"
    trace[Meta.Tactic.cbv.matcher] "{checkEmoji} Succeded with equation: {resolvedCandidate}"
    let toContinue ← forallTelescope (← inferType resolvedCandidate) fun args _ => do
      let some (_, lhs, _, _) := (← inferType args[2]!).heq? | throwError "Heterogenous equality expected"
      return lhs

    let continuedResult ← callback toContinue
    let resolvedCandidate ← mkAppOptM' resolvedCandidate #[.none, continuedResult.value, continuedResult.proof]
    if matcherInfo.arity < args.size then
      let fnType ← inferType continuedResult.value
      let remainingArgs := args.extract matcherInfo.arity
      let congrThm ← getLeftCongruence fnType remainingArgs.size
      let resolvedCandidate ← mkEqOfHEq resolvedCandidate
      let some (_, lhs, rhs) := (← inferType resolvedCandidate).eq? | throwError "equality expected"
      let resolvedCandidate := mkAppN congrThm #[lhs, rhs, resolvedCandidate]
      let resolvedCandidate := mkAppN resolvedCandidate remainingArgs
      let toEvaluate := mkAppN rhs remainingArgs
      let evalResult ← callback toEvaluate
      let resolvedCandidate := mkAppN resolvedCandidate #[← inferType evalResult.value, evalResult.value, evalResult.proof]
      return { value := evalResult.value, proof := resolvedCandidate, isValue := true }
    else
      return { value := continuedResult.value, proof := resolvedCandidate, isValue := true }

def handleRec (name : Name) (levels : List Level) (args : Array Expr) (callback : Expr → CbvM Result) : CbvM Result := do
  trace[Meta.Tactic.cbv.recursor] "handling recursor {name} with {args.size} arguments"
  let evaluated ← args.mapM callback
  let newFn := mkConst name levels
  let newApplication := mkAppN newFn (evaluated.map (·.value))
  let some newApplication ← reduceRecMatcher? newApplication | throwError "Could not reduce recursor application {newApplication}"
  let evaluatedResult ← callback newApplication
  let recursorType ← inferType (mkConst name levels)

  let ⟨congrThm, argKinds⟩ ← getCombinationHEqWithArity recursorType args.size

  let toApply := args.zip evaluated
  let mut congruenceProof := mkAppN congrThm #[newFn]

  -- We apply all the arguments to the congruence lemma
  for ((arg, evalResult), kind) in toApply.zip argKinds do
    congruenceProof := mkAppN congruenceProof #[arg, evalResult.value]
    let mut proof := evalResult.proof
    if kind == .eq then
      proof ← mkEqOfHEq proof
    congruenceProof := .app congruenceProof proof
  congruenceProof := mkAppN congruenceProof #[(← inferType evaluatedResult.value), evaluatedResult.value, evaluatedResult.proof]

  return { value := evaluatedResult.value, proof := congruenceProof, isValue := true }

def handleConstApp (name : Name) (levels : List Level) (args : Array Expr) (callback : Expr → CbvM Result) : CbvM Result := do
  trace[Debug.Meta.Tactic.cbv] "handling constant application {name} with {args.size} arguments"
  let info ← getConstInfo name
  match info with
  | .defnInfo _ =>
    let matcherInfo ← getMatcherInfo? name
    -- Probably here I should also apply function congruence lemmas
    if matcherInfo.isSome then
      handleMatcher name levels args callback matcherInfo.get!
    else
      handleDef name levels args callback
  | .ctorInfo _ => handleIrreducibleConst name levels args callback
  | .inductInfo _ => handleIrreducibleConst name levels args callback
  | .axiomInfo _ => handleIrreducibleConst name levels args callback
  | .opaqueInfo _ => handleIrreducibleConst name levels args callback
  | .thmInfo _ => throwError "Should have been caught by isValue earlier"
  | .recInfo _ => handleRec name levels args callback
  | .quotInfo _ =>
    let res ← handleIrreducibleConst name levels args callback
    if let some toContinue ← reduceRecMatcher? res.value then
      let continuedResult ← callback toContinue
      let proof ← mkHEqTrans res.proof continuedResult.proof
      return {value := continuedResult.value, proof := proof, isValue := true}
    else
      return res

def handleAppDefault (fn : Expr) (args : Array Expr) (callback : Expr → CbvM Result) : CbvM Result := do
  trace[Meta.Tactic.cbv.app] "handling application where function needs to be evaluated first"
  guard !(← isValue fn)

  -- We evaluate the left hand side to a value
  let funArgResult ← callback fn
  let funArgValue := funArgResult.value

  let funType ← inferType fn

  -- We create a new expression to evaluate
  let continuedExpr := mkAppN funArgValue args
  let continuedResult ← callback continuedExpr
  let continuedResultType ← inferType continuedResult.value

  let newCongrArgFun ← getLeftCongruence funType args.size
  let newCongrArgFun := mkAppN newCongrArgFun #[fn, funArgResult.value,  (← mkEqOfHEq funArgResult.proof)]
  let newCongrArgFun := mkAppN newCongrArgFun args
  let newCongrArgFun := mkAppN newCongrArgFun #[continuedResultType, continuedResult.value, continuedResult.proof]
  return { value := continuedResult.value, proof := newCongrArgFun, isValue := true }

def handleApp (fn : Expr) (args : Array Expr) (callback : Expr → CbvM Result) : CbvM Result := do
  trace[Debug.Meta.Tactic.cbv] "evaluating application with function {fn} and {args.size} arguments"
  match fn with
  | .lam .. => handleLambdaApp fn args callback
  | .const name levels => handleConstApp name levels args callback
  | _ => handleAppDefault fn args callback

def handleProj (typeName : Name) (idx : Nat) (val : Expr) (callback : Expr → CbvM Result) : CbvM Result := do
  trace[Meta.Tactic.cbv.projection] "handling projection {typeName}.{idx} on {val}"
  let innerResult ← callback val
  let innerValue := innerResult.value

  -- We solve the projection
  let newExpr := Expr.proj typeName idx innerValue
  let some reduced ← reduceProj? newExpr | throwError "Could not reduce projection {newExpr}"

  -- We continue evaluation
  let continuedResult ← callback reduced

  let fType ← inferType val
  let congrArgFun ← withLocalDecl (← mkFreshUserName `x) BinderInfo.default fType fun var => do
    let theoremLhs := Expr.proj typeName idx var
    let theoremBody ← mkHEq theoremLhs continuedResult.value
    mkLambdaFVars #[var] theoremBody

  let congrArg ← mkCongrArg congrArgFun (← mkEqOfHEq innerResult.proof)

  let finalProof ← mkAppOptM ``Eq.mpr #[none, none, congrArg, continuedResult.proof]
  return { value := continuedResult.value, proof := finalProof, isValue := true }

def withCache (k : CbvM Result) : CbvM Result := do
  let res ← k
  if res.isValue then
    modify (fun state =>
      {state with fullyEvaluated := state.fullyEvaluated.insert res.value})
  return res

partial def cbvCore (e : Expr) : CbvM Result := do
  withTraceNode `Meta.Tactic.cbv (fun
    | .ok result => return m!"{e} => {result.value}"
    | .error err => return m!"{e} => {err.toMessageData}") do
  withCache do
    let res ← normNat e cbvCore
    if h : res.isSome then
      return res.get h
    if (← isValue e) then
      tryValue e
    else
      match e with
      | .app .. => handleApp e.getAppFn e.getAppArgs cbvCore
      | .const .. => return {value := e , proof := ← mkHEqRefl e, isValue := true}
      | .proj typeName idx val => handleProj typeName idx val cbvCore
      | .letE .. =>
        let e ← zetaReduce e
        cbvCore e
      | _ => throwError "cbvCore': not implemented for {e}"

def cbv (e : Expr) : MetaM Result := do
    let ⟨⟨value, proof, isVal⟩, _⟩ ← (cbvCore e).run {compositionThms := {}, leftCongruenceThms := {}, fullyEvaluated := {}}
    return { value := value, proof := ← mkEqOfHEq proof, isValue := isVal }


end Lean.Meta.Tactic.Cbv
